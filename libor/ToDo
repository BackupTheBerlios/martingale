JAVA CODE BUGS:

1 Optimizers: BFGS.lineSearch() : 

Compute rs before rescaling. Bug in relativeSize() "d[j]" should be "y[j]".
Bug in backTrack(): don't reset f2 to zero.


C++ CODE:

1. OPTIMIZERS. 

BFGS: reset the Hessian to the identity if no movement in x is detected.
Do this a couple of times and keep a counter how often the optimizer was restarted that way.
It is highly unlikely that the Hessian can build up global curvature information for an arbitrary
surface. Better to work with local information. Same applies to Java code.

2. LIBOR. 

A. Run a simulation to determine the caplet and swaption smiles resulting from the stochastic
volatility in a lattice for the driftless LMM. Simply allocate a data vector in each node containing all
the caplet or swaption prices. The computation should be quite quick.

B. Investigate the predictor-corrector drift approximation. Why do caplet prices blow up in dimension
n>=70 but everything works fine for n<=60.

C. Calibration experiments. Determine how well the driftless model can be calibrated to prices
generated in a predictor-corrector model. How well can we calibrate with constant U_j-volatilities.

