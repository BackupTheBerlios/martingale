<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="SyntheticData/html-info.css" type="text/css">
</head>
<body>

<h1>TO DO</h1>

<h3>LiborMarketModel and drived classes:</h3>

the use of the cache XLvec is the only reason that the member function
XLvec(t,p) is not constant and that propagates through basically all the
Libor quantity member functions.
Reflect upon wether it's worth it or wether we should return from the stack.

<h3>INCLUDE ANALYIS</h3>

Get all definitions that need an include out of header files.
Use forward declarations instead of includes in header files.
Headers include much less and the forward declarations give us a much better 
picture of the dependencies.
<p>
Move all implementations out of headers. Then the declarations in the headers
will only use class and function names and these can be forward declared.
No forward declared functions can be called in a header and this includes the constructors
of forward declared classes in initialization lists!


<h3>7-13-03:</h3>

All files have been rewritten in this way and there is only one problem left before
linkage: No method Random::sTN()... Check if unwanted ifndef in source files.


<h3>7-17-03:</h3>


Include structure is still sloppy.
Why don't we have to qualify "cout" as "std::cout"??
Should we simply include &lt;string&gt; and &lt;iostream&gt;  in TypedefsMacros.h (and hence everywhere)?
Explore the difference between &lt;math.h&gt; and &lt;cmath&gt;.
<p>
LmmLattice2F,3F: implement a choice of wether we rescale the covariation matrix root to preserve
volatilities or not so we can test what works better.
<p>
Known problems:
<ul>
<li>std::ostream operator &lt;&lt; (std::ostream& os, const SomeType& x)
doesn't link but x->printSelf(os) works. Why is that?
</li>
<li>Examples::brownianMotionInBall(dim,T,dt,nPath) dies on array index out of bounds error.
</li>
</ul>


<h3>7-19-03:</h3>

<ul>
<li>Check if synthetic caplet prices are written correctly by the calibrator object.
   Why is calibration to caplet prices so atrocious?</li>

<li>Go after major memory leak detected by the old calibration routine.
   Check if matrix operations (especially pseudo square roots and log-Libor covariation
   matries deallocate everything properly.
</li>
<li>Implement  SlowLMMLattice, where the nodes do not cache the vector H, only the
   variables evolved in the lattice from which this vector can be computed.
   This uses much less memory at the expense of computational effort.
   We can have millions of nodes.</li>
   
<li>Implementation of Bermudan style options in lattice both Libor and otherwise. </li>

<li>Redesign the matrix classes using traits as template parameters to shrink the code size.
     Use allocaters for upper triangular, lower triangular, symmetric etc matrices.
     Find out about iterator design (otherwise methods rowBegin(i), rowEnd(i)).
     Since we don't have matrix expressions to deal with "#define MATRIX-MAX-DIM"
     limit all matrices to this size and create a static workspace of that size. Then write to that 
     workspace in matrix products (saves memory allocation).</li>
</ul>


<h3>7-26-03:</h3>

<ul>
<li>Fix Book: 6.11.3: k_j  should be c_j. Elaborate on implementation of calibration.<br>
     6.11.3: recursive computation of the k_j=c_j: c_i=x_i since G_i(0)=1.</li>

<li><b>Calibration:</b> Why are swaption prices in the DriftlessLMM  10 times bigger than in
the Predictor-Corrector LMM when the caplet prices agree? Is there a bug in writing the swaption prices
from the current parameters of the factorloading. This would not be detected by the calibration routine
if it calibrates a DriftllessLMM to prices generated by a DriftlessLMM. Verify against prices from an LMM 
rather than from the calibrator object.
</li>

<li>Write extensive doxygen-docs for LiborCalibrator.h. Delete the old doxy-docs and run
doxygen again from clean slate. Maybe this reduces the doxygen-errors.
</li>

</ul>


<h3>7-26-03:</h3>

BUG in the analytic swaption formula in predictor-corrector LMM detected.
No agreement with Monte Carlo.
This can account for the problems in calibrating a driftless LMM to predictor-corrector
computed prices.
Rework this using the technique for the driftless LMM.


<h3>7-28-03:</h3>

Run tests and examine the analytic swaption price formulas in the predictor-corrector LMM.
Both formulas produce very similar and often quite inaccurate prices.


<h3>8-4-03</h3>

No known bugs at present. Implement lightweight LMM-lattices and Bermudan options.
<p>
<b>Akwardness</b> since UTRMatrix&lt;Real&gt; is not the same as UTRRealMatrix. This is due to the fact that there are
no templated typdefs. Affects: RandomObject. The covariation matrix has type UTRMatrix&lt;S&gt;.
Thus the functionality of UTRRealMatrix is not available for RandomObjects with Real scalars
(factor analysis, matrix functions). Possible solutions:
<p>
Move the functionality of UTRRealMatrix to the more general type  UTRMatrix&lt;S&gt; or limit 
RandomObjects to Real scalars.

<a name="8-5-03"></a>
<h3>8-5-03</h3>

State Lattice-rewrite: Nodes finished. Split<br>
template&lt;class LmmNode&gt; class LmmLattice
<p>
Into subclasses<br>
template&lt;class LmmNode&gt; class LmmLattice2F,3F
<p>
Merely the buildLattice(int m) methods have to be adapted and moved into the header file.
Then rework the BasketLattice in exactly the same manner.
<p>
Note: 4 factor lattices are not reasonable since they generate 100s of millions of nodes.
Therefore it is not worth introducing 4 dimensional arrays for node registry.

<h3>8-7-03:</h3>

Memory leak in all lattices, NO DEALLOCATION AT ALL despite the fact that the list destructor is called
on every node list at each time t.  Read up on list deallocation.
Check the proper deallocation of nodes.


<h3>8-9-03:</h3>

Get the lattice swaption tests to compile and run and see how it works.


<h3>8-10-03:</h3>

LmmLattice, BasketLattice, Node: <br>
Get rid of the heavyeight nodes and standardize on lightweight ones.
Simplification in the templatization. Hopefully will speed up compiles.
Preliminary tests show that volatility rescaling in low factor models makes
the pricing of at the money swaptions significantly less precise.
Run more tests and point this out in the book.
<p>
Pricing of swaptions in a lattice works the first time through the main loop
in TestLMM.h#testLatticeSwaption() but dies on array index out of bound error
the second time through the loop. 


<h3>8-11-03:</h3>

Fix the above mentioned bug.
Clean up the include structure: get rid of &lt;iostream&gt; in all headers, include this in the
source files instead. In headers declare
<p>
class std::ostream;
<p>
In source files include &lt;iostream&gt; and declare
<p>
using std::ostream;<br>
using std::cout;<br>
using std::endl;<br>
<p>
In general make includes in headers MINIMAL (compile times).
Get rid of all operators
<p>
ostream& operator &lt;&lt; (ostream& os, const T& t)
<p>
since these are now covered by a template in Utils.h.


<a name="8-12-03"></a>
<h3>8-12-03:</h3>

Clear up the problem with the typedef in forward declarations and remove "#include Matrix.h"
from headers if it is not really needed.
Seemingly we don't have to declare std::ostream; Find out if this is really so or if <iostream> is
sloppily included somewhere.
Clear up the linker problem when splitting TestLMM.h into header and source file.
Split all Test*.h files into header and source files.


<a name="8-14-03"></a>
<h3>8-14-03:</h3>

Finish rewrite of Derivitives.h --> Option.h.
The method isExercisable(int t) depends on the step size which can vary in a lattice.
Use continuous times instead:
<p>
isExercisable(Real t).
<p>
Status: with this Option and LiborDerivative are finished but the Swaptions have to be rewritten.
Implement BermudanSwpations and European and American BasketOptions.


<h3>8-15-03:</h3>

Get rid of the strange linker error and test the option pricing code.
Split all Test*.h files into header and source files.


<h3>8-16-03:</h3>

Lattice volatility rescaling: introduce a parameter which allows us to 
control to which percent the volatility is rescaled. Swaption price experiments
indicate that full rescale overshoots the target.

<p>Implement Monte Carlo American option pricing: exercise triggers,
each option gets a method to provide a default exercise trigger.
This is used to compute the forwardPayoffAlongCurrentPath().


<a name="8-18-03"></a>
<h3>8-18-03:</h3>

Monte Carlo pricing of zero coupon bonds fails, lattice pricing works OK,
general bonds work OK. Get to the root of this.



<a name="8-20-03"></a>
<h3>8-20-03:</h3>

Monte Carlo prices of Berudan swaptions based on the PjTrigger are significantly less than 
lattice computed prices. Find out what the reason is:
<ul>
<li>Is the trigger suboptimal?</li>
<li>Is the bfgs optimizer computing the parameters for the exercise boundary not working well?
There is some evidence for this: the verbose version shows that only the third variable is
moved significantly.</li>
<li>Is the lattice buggy for Bermudan exercise? Check if the exercise times are computed
correctly.</li>
</ul>


<h3>8-26-03:</h3>

Fix file descriptions: BasketLattice.h, LiborFactorLoading.h, generally link to the class description
with {@link classname} in all file descriptions. Check if BrownianMotionInBall runs correctly.


<h3>9-1-03:</h3>

<p>Simplify the Monte Carlo pricing of options as follows: no explicit mentioning of path computations
Indeed some options might use direct sampling). The fundamental virtual method becomes</p>

<code>
nextForwardPayoff()<br>
nextForwardPayoffControlVariatePair()
</code>

<p>Get rid of PathGenerators. Write a note about include paths and linker options needed to 
compile the project, credits for libraries used.</p>

<p><b>Warning:</b> Since the method <code>Option::isExercisable(Real t)</code>
uses continuous time t, the lattice pricing code in Pricing.h relies
on the comparison of floats when instantiated for Bermudan swaptions. 
This is fragile and works only if the exercise times are exact integral multiples of the
lattice time step. Reflect upon alternatives.



<h3>9-2-03:</h3>

<p>Split all the Test*.h files into headers and source files, same with ExercisePlot.h.
Check if BrownianMotionInBall runs correctly.</p>

<p><b>Documentation</b> Write credits for libraries used, where to get, what to include,
what to link against (especially for gnu-plotutils). Work on makefile to build library.
</p>


<h3>9-6-03:</h3>

Documentation: adapt the file and class descriptions of
Classes <code>Node, Lattice, LmmLattice, BasketLattice, LiborFunctional</code> 
to reflect the new setup. Elaborate on the reason for the templatization.




</body>
</html>

